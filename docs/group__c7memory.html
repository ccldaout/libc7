<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libc7: c7memory.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libc7
   &#160;<span id="projectnumber">r0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">c7memory.h</div>  </div>
</div><!--header-->
<div class="contents">

<p>メモリ取得関数の拡張機能を提供する。  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
fundamental</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe01ac89f09c553a7b7bf0d7dec58a21c"></a>基本的なメモリ取得関数</p>
<p>標準ライブラリ関数でメモリ確保に失敗した場合に c7status を用いてエラー情報をスレッド毎に保存する。 </p>
</td></tr>
<tr class="memitem:gad713ef400dc032b0214ece10b9b27ec8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gad713ef400dc032b0214ece10b9b27ec8">c7_memdup</a> (const void *addr, size_t size)</td></tr>
<tr class="memdesc:gad713ef400dc032b0214ece10b9b27ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリを確保したうえで複製する。  <a href="#gad713ef400dc032b0214ece10b9b27ec8">More...</a><br /></td></tr>
<tr class="separator:gad713ef400dc032b0214ece10b9b27ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5b2a47e9cc6478b47f7eb4d0e7ddee"><td class="memItemLeft" align="right" valign="top"><a id="gaef5b2a47e9cc6478b47f7eb4d0e7ddee"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gaef5b2a47e9cc6478b47f7eb4d0e7ddee">c7_malloc</a> (size_t z)</td></tr>
<tr class="memdesc:gaef5b2a47e9cc6478b47f7eb4d0e7ddee"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリを確保に失敗したら c7status でエラー情報を記録する標準関数の拡張版 <br /></td></tr>
<tr class="separator:gaef5b2a47e9cc6478b47f7eb4d0e7ddee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f63b9fc0ac8152c116aaff36f30f2d9"><td class="memItemLeft" align="right" valign="top"><a id="ga9f63b9fc0ac8152c116aaff36f30f2d9"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga9f63b9fc0ac8152c116aaff36f30f2d9">c7_calloc</a> (size_t n, size_t z)</td></tr>
<tr class="memdesc:ga9f63b9fc0ac8152c116aaff36f30f2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリを確保に失敗したら c7status でエラー情報を記録する標準関数の拡張版 <br /></td></tr>
<tr class="separator:ga9f63b9fc0ac8152c116aaff36f30f2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa411994b453c05297a59fe101b8533e6"><td class="memItemLeft" align="right" valign="top"><a id="gaa411994b453c05297a59fe101b8533e6"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gaa411994b453c05297a59fe101b8533e6">c7_realloc</a> (void *p, size_t n)</td></tr>
<tr class="memdesc:gaa411994b453c05297a59fe101b8533e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリを確保に失敗したら c7status でエラー情報を記録する標準関数の拡張版 <br /></td></tr>
<tr class="separator:gaa411994b453c05297a59fe101b8533e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
memory group</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc37c08bc8c63950b48cdd83c0fef5f9e"></a>メモリ管理のグループ化.</p>
<p>一連の動的確保したメモリをグループとして管理する。一度の操作でグループ内のメモリを開放することができる。 </p>
</td></tr>
<tr class="memitem:ga8dbd262c5860edef7b17371440d3a622"><td class="memItemLeft" align="right" valign="top">typedef struct c7_mgroup_t_ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a></td></tr>
<tr class="memdesc:ga8dbd262c5860edef7b17371440d3a622"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリグループオブジェクトへのポインタ。  <a href="#ga8dbd262c5860edef7b17371440d3a622">More...</a><br /></td></tr>
<tr class="separator:ga8dbd262c5860edef7b17371440d3a622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67590aeb15949971100e4d296208b909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga67590aeb15949971100e4d296208b909">c7_mg_thread_local</a> (void)</td></tr>
<tr class="memdesc:ga67590aeb15949971100e4d296208b909"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッド毎に固有のメモリグループを得る。  <a href="#ga67590aeb15949971100e4d296208b909">More...</a><br /></td></tr>
<tr class="separator:ga67590aeb15949971100e4d296208b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2848ad5927ca56debe3d1ffcb5df6180"><td class="memItemLeft" align="right" valign="top"><a id="ga2848ad5927ca56debe3d1ffcb5df6180"></a>
<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga2848ad5927ca56debe3d1ffcb5df6180">c7_mg_new</a> (void)</td></tr>
<tr class="memdesc:ga2848ad5927ca56debe3d1ffcb5df6180"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリグループを作成して戻す。 <br /></td></tr>
<tr class="separator:ga2848ad5927ca56debe3d1ffcb5df6180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74229be9533ec954cc9595b9c6c956a7"><td class="memItemLeft" align="right" valign="top"><a id="ga74229be9533ec954cc9595b9c6c956a7"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga74229be9533ec954cc9595b9c6c956a7">c7_mg_memdup</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> mg, const void *addr, size_t size)</td></tr>
<tr class="memdesc:ga74229be9533ec954cc9595b9c6c956a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__c7memory.html#gad713ef400dc032b0214ece10b9b27ec8" title="メモリを確保したうえで複製する。">c7_memdup()</a> のメモリグループ版。mg が NULL ポインタの場合は <a class="el" href="group__c7memory.html#gaef5b2a47e9cc6478b47f7eb4d0e7ddee" title="メモリを確保に失敗したら c7status でエラー情報を記録する標準関数の拡張版">c7_malloc()</a> を呼びグループ化しない。 <br /></td></tr>
<tr class="separator:ga74229be9533ec954cc9595b9c6c956a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e6ead1e3ee080a407f528110e9a350c"><td class="memItemLeft" align="right" valign="top"><a id="ga7e6ead1e3ee080a407f528110e9a350c"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga7e6ead1e3ee080a407f528110e9a350c">c7_mg_malloc</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> mg, size_t size)</td></tr>
<tr class="memdesc:ga7e6ead1e3ee080a407f528110e9a350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">malloc のメモリグループ版。mg が NULL ポインタの場合は <a class="el" href="group__c7memory.html#gaef5b2a47e9cc6478b47f7eb4d0e7ddee" title="メモリを確保に失敗したら c7status でエラー情報を記録する標準関数の拡張版">c7_malloc()</a> を呼びグループ化しない。 <br /></td></tr>
<tr class="separator:ga7e6ead1e3ee080a407f528110e9a350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga895ed2fae84a67ea79466907c564fc2e"><td class="memItemLeft" align="right" valign="top"><a id="ga895ed2fae84a67ea79466907c564fc2e"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga895ed2fae84a67ea79466907c564fc2e">c7_mg_calloc</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> mg, size_t n, size_t z)</td></tr>
<tr class="memdesc:ga895ed2fae84a67ea79466907c564fc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calloc のメモリグループ版。mg が NULL ポインタの場合は <a class="el" href="group__c7memory.html#ga9f63b9fc0ac8152c116aaff36f30f2d9" title="メモリを確保に失敗したら c7status でエラー情報を記録する標準関数の拡張版">c7_calloc()</a> を呼びグループ化しない。 <br /></td></tr>
<tr class="separator:ga895ed2fae84a67ea79466907c564fc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a882028d678b0277f35fa78126eb90"><td class="memItemLeft" align="right" valign="top"><a id="ga74a882028d678b0277f35fa78126eb90"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga74a882028d678b0277f35fa78126eb90">c7_mg_realloc</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> mg, void *u_addr, size_t size)</td></tr>
<tr class="memdesc:ga74a882028d678b0277f35fa78126eb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">realloc のメモリグループ版。mg が NULL ポインタの場合は <a class="el" href="group__c7memory.html#gaa411994b453c05297a59fe101b8533e6" title="メモリを確保に失敗したら c7status でエラー情報を記録する標準関数の拡張版">c7_realloc()</a> を呼びグループ化しない。<br />
 u_addr が mg とは異なるメモリグループであった場合、本来所属するメモリグループにそのまま属する。 <br /></td></tr>
<tr class="separator:ga74a882028d678b0277f35fa78126eb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac75024e709ccc21b6eb4312680a45294"><td class="memItemLeft" align="right" valign="top"><a id="gac75024e709ccc21b6eb4312680a45294"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gac75024e709ccc21b6eb4312680a45294">c7_mg_trade</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> trgmg, <a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> srcmg, void *src_addr)</td></tr>
<tr class="memdesc:gac75024e709ccc21b6eb4312680a45294"><td class="mdescLeft">&#160;</td><td class="mdescRight">srcmg のグループに所属する src_addr メモリを trgmg の所属へと変更する。 srcmg, trgmg とも NULL ポインタであってはならない。 <br /></td></tr>
<tr class="separator:gac75024e709ccc21b6eb4312680a45294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e4f2ca3e8ee76141d1f6c931b0d862"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga09e4f2ca3e8ee76141d1f6c931b0d862">c7_mg_unlink</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> mg, void *u_addr, size_t content_size)</td></tr>
<tr class="memdesc:ga09e4f2ca3e8ee76141d1f6c931b0d862"><td class="mdescLeft">&#160;</td><td class="mdescRight">mg のグループに所属する content_size バイトの u_addr メモリを mg のグループから切り離す。u_addr のアドレスは無意味になることに注意が必要。  <a href="#ga09e4f2ca3e8ee76141d1f6c931b0d862">More...</a><br /></td></tr>
<tr class="separator:ga09e4f2ca3e8ee76141d1f6c931b0d862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f31cf0ece3e3d913869df35b8d1250b"><td class="memItemLeft" align="right" valign="top"><a id="ga2f31cf0ece3e3d913869df35b8d1250b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga2f31cf0ece3e3d913869df35b8d1250b">c7_mg_free</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> mg, void *u_addr)</td></tr>
<tr class="memdesc:ga2f31cf0ece3e3d913869df35b8d1250b"><td class="mdescLeft">&#160;</td><td class="mdescRight">u_addr メモリを mg のグループから切り離し free で開放する。mg が NULL の場合は単純に free で解放する。<br />
 u_addr が mg とは異なるメモリグループであった場合も、、本来所属するメモリグループから切り離される。 <br /></td></tr>
<tr class="separator:ga2f31cf0ece3e3d913869df35b8d1250b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4771eedcfc8bd26083bae9433fbcd07e"><td class="memItemLeft" align="right" valign="top"><a id="ga4771eedcfc8bd26083bae9433fbcd07e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga4771eedcfc8bd26083bae9433fbcd07e">c7_mg_freeall</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> mg)</td></tr>
<tr class="memdesc:ga4771eedcfc8bd26083bae9433fbcd07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">mg のグループに所属するメモリについて <a class="el" href="group__c7memory.html#ga2f31cf0ece3e3d913869df35b8d1250b" title="u_addr メモリを mg のグループから切り離し free で開放する。mg が NULL の場合は単純に free で解放する。  u_addr が mg とは異なるメモリグループであった場合も、...">c7_mg_free()</a> を呼び出す。mg の指すメモリグループ自体は存続する。 <br /></td></tr>
<tr class="separator:ga4771eedcfc8bd26083bae9433fbcd07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2076d9d1dfe49d2c7565b79098941dbe"><td class="memItemLeft" align="right" valign="top"><a id="ga2076d9d1dfe49d2c7565b79098941dbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga2076d9d1dfe49d2c7565b79098941dbe">c7_mg_destroy</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> mg)</td></tr>
<tr class="memdesc:ga2076d9d1dfe49d2c7565b79098941dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">mg に対して <a class="el" href="group__c7memory.html#ga4771eedcfc8bd26083bae9433fbcd07e" title="mg のグループに所属するメモリについて c7_mg_free() を呼び出す。mg の指すメモリグループ自体は存続する。">c7_mg_freeall()</a> を呼んだあと mg グループ自体も解放する。 <br /></td></tr>
<tr class="separator:ga2076d9d1dfe49d2c7565b79098941dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
stackable memory group</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpeefa0af2c61f049f382b4cf308f5f76c"></a>スタック可能なメモリグループ.</p>
<p>スレッド毎にメモリグループをスタックとして管理する。常に現在のメモリグループが 存在するため、メモリグループを引数では指定しない。この性質のため、メモリ確保操作と 自スレッドで確保したスタック可能なメモリグループのメモリの操作はスレッドセーフである。</p>
<p>なおこの機能はC7スレッド(<a class="el" href="group__c7thread.html#ga3a166c944106e3acb402ba6908e5fed0" title="C7スレッドを起動する。">c7_thread_start()</a> もしくは <a class="el" href="group__c7thread.html#gac3a7a1bd8c1911ed232b1e9433680419" title="C7スレッドの生成から起動までをまとめて行なう。 この関数は、c7_thread_new(), c7_thread_set_name(), c7_thread_set_stacksize(),...">c7_thread_run()</a> で起動した スレッド)でしか正しく動作しない。</p>
<dl class="section note"><dt>Note</dt><dd>C7スレッド終了時には <a class="el" href="group__c7memory.html#gab12ae39f16b183b9f35e870bc4e5040b" title="現在のメモリグループを完全に解放(c7_mg_destroy(c7_sg_current_mg()))し、 スタックからポップしたメモリグループを現在のメモリグループとする。 スタックからポップできれば...">c7_sg_pop()</a> してないメモリもすべて解放される。 </dd></dl>
</td></tr>
<tr class="memitem:ga0ded2ffe63a9f3ace53e99a5a42f50d8"><td class="memItemLeft" align="right" valign="top"><a id="ga0ded2ffe63a9f3ace53e99a5a42f50d8"></a>
<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga0ded2ffe63a9f3ace53e99a5a42f50d8">c7_sg_current_mg</a> (void)</td></tr>
<tr class="memdesc:ga0ded2ffe63a9f3ace53e99a5a42f50d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドの現在のメモリグループを戻す。これは <a class="el" href="group__c7memory.html#ga67590aeb15949971100e4d296208b909" title="スレッド毎に固有のメモリグループを得る。">c7_mg_thread_local()</a> の戻り値とは異なる。 <br /></td></tr>
<tr class="separator:ga0ded2ffe63a9f3ace53e99a5a42f50d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae711ea17a571c63162ab8cef9affaeda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c7types.html#ga32dffe853a91b70665fd4c3b18a9d288">c7_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gae711ea17a571c63162ab8cef9affaeda">c7_sg_push</a> (void)</td></tr>
<tr class="memdesc:gae711ea17a571c63162ab8cef9affaeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在のメモリグループをスタックへプッシュし、新しく作成したメモリグループを現在のメモリグループとする。 メモリを確保できれば <a class="el" href="group__c7types.html#gga32dffe853a91b70665fd4c3b18a9d288a08c6b322450e442caf038e6d5009ce3c" title="真 (C言語規格上では不正確)">C7_TRUE</a> を戻し、失敗すれば <a class="el" href="group__c7types.html#gga32dffe853a91b70665fd4c3b18a9d288a6a78d27e2a39c3f5ff8b63b6484e7359" title="偽 (C言語規格上で正確)">C7_FALSE</a> を戻す。  <a href="#gae711ea17a571c63162ab8cef9affaeda">More...</a><br /></td></tr>
<tr class="separator:gae711ea17a571c63162ab8cef9affaeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12ae39f16b183b9f35e870bc4e5040b"><td class="memItemLeft" align="right" valign="top"><a id="gab12ae39f16b183b9f35e870bc4e5040b"></a>
<a class="el" href="group__c7types.html#ga32dffe853a91b70665fd4c3b18a9d288">c7_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gab12ae39f16b183b9f35e870bc4e5040b">c7_sg_pop</a> (void)</td></tr>
<tr class="memdesc:gab12ae39f16b183b9f35e870bc4e5040b"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在のメモリグループを完全に解放(c7_mg_destroy(c7_sg_current_mg()))し、 スタックからポップしたメモリグループを現在のメモリグループとする。 スタックからポップできれば <a class="el" href="group__c7types.html#gga32dffe853a91b70665fd4c3b18a9d288a08c6b322450e442caf038e6d5009ce3c" title="真 (C言語規格上では不正確)">C7_TRUE</a> を戻し、そうでなければ(<a class="el" href="group__c7memory.html#gae711ea17a571c63162ab8cef9affaeda" title="現在のメモリグループをスタックへプッシュし、新しく作成したメモリグループを現在のメモリグループとする。 メモリを確保できれば C7_TRUE を戻し、失敗すれば C7_FALSE を戻す。">c7_sg_push()</a>の回数を越えて この関数が呼び出された) <a class="el" href="group__c7types.html#gga32dffe853a91b70665fd4c3b18a9d288a6a78d27e2a39c3f5ff8b63b6484e7359" title="偽 (C言語規格上で正確)">C7_FALSE</a> を戻す。 <br /></td></tr>
<tr class="separator:gab12ae39f16b183b9f35e870bc4e5040b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38df1f1e7376d70bbbe51d30f831e5f"><td class="memItemLeft" align="right" valign="top"><a id="gac38df1f1e7376d70bbbe51d30f831e5f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gac38df1f1e7376d70bbbe51d30f831e5f">c7_sg_memdup</a> (const void *addr, size_t size)</td></tr>
<tr class="memdesc:gac38df1f1e7376d70bbbe51d30f831e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">c7_mg_memdup(c7_sg_current_mg(), addr, size) を呼び出す。 <br /></td></tr>
<tr class="separator:gac38df1f1e7376d70bbbe51d30f831e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga825abda9aa39142ed800bee13df1faa7"><td class="memItemLeft" align="right" valign="top"><a id="ga825abda9aa39142ed800bee13df1faa7"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga825abda9aa39142ed800bee13df1faa7">c7_sg_malloc</a> (size_t size)</td></tr>
<tr class="memdesc:ga825abda9aa39142ed800bee13df1faa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">c7_mg_malloc(c7_sg_current_mg(), size) を呼び出す。 <br /></td></tr>
<tr class="separator:ga825abda9aa39142ed800bee13df1faa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a245de9b64b265912a3c194dc77027a"><td class="memItemLeft" align="right" valign="top"><a id="ga3a245de9b64b265912a3c194dc77027a"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga3a245de9b64b265912a3c194dc77027a">c7_sg_calloc</a> (size_t n, size_t z)</td></tr>
<tr class="memdesc:ga3a245de9b64b265912a3c194dc77027a"><td class="mdescLeft">&#160;</td><td class="mdescRight">c7_mg_calloc(c7_sg_current_mg(), n, size) を呼び出す。 <br /></td></tr>
<tr class="separator:ga3a245de9b64b265912a3c194dc77027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6909b86209fa26b464ed66de77b35bdb"><td class="memItemLeft" align="right" valign="top"><a id="ga6909b86209fa26b464ed66de77b35bdb"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga6909b86209fa26b464ed66de77b35bdb">c7_sg_realloc</a> (void *u_addr, size_t size)</td></tr>
<tr class="memdesc:ga6909b86209fa26b464ed66de77b35bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">c7_mg_realloc(c7_sg_current_mg(), u_addr, size) を呼び出す。 <br /></td></tr>
<tr class="separator:ga6909b86209fa26b464ed66de77b35bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d76f8cfdddfc8a531cc0380b0857bed"><td class="memItemLeft" align="right" valign="top"><a id="ga6d76f8cfdddfc8a531cc0380b0857bed"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga6d76f8cfdddfc8a531cc0380b0857bed">c7_sg_unlink</a> (void *u_addr, size_t content_size)</td></tr>
<tr class="memdesc:ga6d76f8cfdddfc8a531cc0380b0857bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">c7_mg_unlink(c7_sg_current_mg(), u_addr, content_size) を呼び出す。 <br /></td></tr>
<tr class="separator:ga6d76f8cfdddfc8a531cc0380b0857bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab244a8ac69e168050a8b0982def657e7"><td class="memItemLeft" align="right" valign="top"><a id="gab244a8ac69e168050a8b0982def657e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gab244a8ac69e168050a8b0982def657e7">c7_sg_free</a> (void *u_addr)</td></tr>
<tr class="memdesc:gab244a8ac69e168050a8b0982def657e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">c7_mg_free(c7_sg_current_mg(), u_addr) を呼び出す。 <br /></td></tr>
<tr class="separator:gab244a8ac69e168050a8b0982def657e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gababbafc6ecd1fb10a1416695139f41be"><td class="memItemLeft" align="right" valign="top"><a id="gababbafc6ecd1fb10a1416695139f41be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gababbafc6ecd1fb10a1416695139f41be">c7_sg_freeall</a> (void)</td></tr>
<tr class="memdesc:gababbafc6ecd1fb10a1416695139f41be"><td class="mdescLeft">&#160;</td><td class="mdescRight">c7_mg_freeall(c7_sg_current_mg()) を呼び出す。 <br /></td></tr>
<tr class="separator:gababbafc6ecd1fb10a1416695139f41be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
variable size buffer</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp45355b1d9f9638c858e0aabb6b0555c3"></a>可変バッファ. </p>
</td></tr>
<tr class="memitem:ga79eed08ce542a1af97cd4be384663dba"><td class="memItemLeft" align="right" valign="top"><a id="ga79eed08ce542a1af97cd4be384663dba"></a>
typedef struct c7_vbuf_t_ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga79eed08ce542a1af97cd4be384663dba">c7_vbuf_t</a></td></tr>
<tr class="memdesc:ga79eed08ce542a1af97cd4be384663dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">可変バッファオブジェクトへのポインタ。このポインタのことを可変バッファあるいは vbuf と呼ぶ。 <br /></td></tr>
<tr class="separator:ga79eed08ce542a1af97cd4be384663dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d540402462ef8b935fb0673d3c2edc"><td class="memItemLeft" align="right" valign="top"><a id="ga12d540402462ef8b935fb0673d3c2edc"></a>
<a class="el" href="group__c7memory.html#ga79eed08ce542a1af97cd4be384663dba">c7_vbuf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga12d540402462ef8b935fb0673d3c2edc">c7_vbuf_new_std</a> (void)</td></tr>
<tr class="memdesc:ga12d540402462ef8b935fb0673d3c2edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">可変バッファの生成。メモリ確保・伸長は標準機能(<a class="el" href="group__c7memory.html#gaef5b2a47e9cc6478b47f7eb4d0e7ddee" title="メモリを確保に失敗したら c7status でエラー情報を記録する標準関数の拡張版">c7_malloc()</a>など)で行なう。 <br /></td></tr>
<tr class="separator:ga12d540402462ef8b935fb0673d3c2edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaffbf5991f0498b60faabd81ec53b76"><td class="memItemLeft" align="right" valign="top"><a id="gafaffbf5991f0498b60faabd81ec53b76"></a>
<a class="el" href="group__c7memory.html#ga79eed08ce542a1af97cd4be384663dba">c7_vbuf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#gafaffbf5991f0498b60faabd81ec53b76">c7_vbuf_new_mg</a> (<a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> mg)</td></tr>
<tr class="memdesc:gafaffbf5991f0498b60faabd81ec53b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">可変バッファの生成。メモリ確保・伸長は mg のメモリグループで行なう。 <br /></td></tr>
<tr class="separator:gafaffbf5991f0498b60faabd81ec53b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84df286a4729be5f681650b3f9fde2e6"><td class="memItemLeft" align="right" valign="top"><a id="ga84df286a4729be5f681650b3f9fde2e6"></a>
<a class="el" href="group__c7memory.html#ga79eed08ce542a1af97cd4be384663dba">c7_vbuf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga84df286a4729be5f681650b3f9fde2e6">c7_vbuf_new_sg</a> (void)</td></tr>
<tr class="memdesc:ga84df286a4729be5f681650b3f9fde2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">可変バッファの生成。メモリ確保・伸長は現在のスタック可能メモリグループで行なう。 <br /></td></tr>
<tr class="separator:ga84df286a4729be5f681650b3f9fde2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b37c8a5ffddbac98ff42e266ba024f9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga5b37c8a5ffddbac98ff42e266ba024f9">c7_vbuf_get</a> (<a class="el" href="group__c7memory.html#ga79eed08ce542a1af97cd4be384663dba">c7_vbuf_t</a> vb, size_t n)</td></tr>
<tr class="memdesc:ga5b37c8a5ffddbac98ff42e266ba024f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">vbの可変バッファのサイズを最低 n バイト確保して、そのアドレスを戻す。  <a href="#ga5b37c8a5ffddbac98ff42e266ba024f9">More...</a><br /></td></tr>
<tr class="separator:ga5b37c8a5ffddbac98ff42e266ba024f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0017119f4a81be68624ed75011e50eb5"><td class="memItemLeft" align="right" valign="top"><a id="ga0017119f4a81be68624ed75011e50eb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c7memory.html#ga0017119f4a81be68624ed75011e50eb5">c7_vbuf_free</a> (<a class="el" href="group__c7memory.html#ga79eed08ce542a1af97cd4be384663dba">c7_vbuf_t</a> vb)</td></tr>
<tr class="memdesc:ga0017119f4a81be68624ed75011e50eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">vb の可変バッファを解放する。 <br /></td></tr>
<tr class="separator:ga0017119f4a81be68624ed75011e50eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>メモリ取得関数の拡張機能を提供する。 </p>
<ul>
<li>標準ライブラリのメモリ取得関数にエラー時の処理を追加</li>
<li>取得したメモリをグループ化する機能</li>
<li>可変バッファ </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8dbd262c5860edef7b17371440d3a622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dbd262c5860edef7b17371440d3a622">&#9670;&nbsp;</a></span>c7_mgroup_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct c7_mgroup_t_* <a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリグループオブジェクトへのポインタ。 </p>
<p>メモリグループオブジェクトの詳細は関知しないこと。このポインタのことを略してメモリグループと呼ぶ。 <b>メモリグループへのアクセスはスレッドセーフではないため、複数スレッドで同一のメモリグループを 使用する場合は呼び出し側で排他制御する必要がある。</b> </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad713ef400dc032b0214ece10b9b27ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad713ef400dc032b0214ece10b9b27ec8">&#9670;&nbsp;</a></span>c7_memdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* c7_memdup </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリを確保したうえで複製する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>コピー対象のアドレス </td></tr>
    <tr><td class="paramname">size</td><td>コピー対象のサイズ(bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>メモリの確保に成功すれば確保したアドレスを戻す。失敗すれば NULL を戻す。 </dd></dl>
<dl class="section see"><dt>See also</dt><dd>malloc(3) </dd></dl>

</div>
</div>
<a id="ga67590aeb15949971100e4d296208b909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67590aeb15949971100e4d296208b909">&#9670;&nbsp;</a></span>c7_mg_thread_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a> c7_mg_thread_local </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>スレッド毎に固有のメモリグループを得る。 </p>
<dl class="section return"><dt>Returns</dt><dd>スレッド単位で初期化されたメモリグループを戻す。</dd></dl>
<dl class="section note"><dt>Note</dt><dd>このメモリグループは <a class="el" href="group__c7thread.html#ga3a166c944106e3acb402ba6908e5fed0" title="C7スレッドを起動する。">c7_thread_start()</a> もしくは <a class="el" href="group__c7thread.html#gac3a7a1bd8c1911ed232b1e9433680419" title="C7スレッドの生成から起動までをまとめて行なう。 この関数は、c7_thread_new(), c7_thread_set_name(), c7_thread_set_stacksize(),...">c7_thread_run()</a> で起動した スレッドでのみ意味を持ち、スレッド終了時にこのメモリグループは開放される。 スレッド生存期間中には確保しておきたいが終了後に開放したいが、TLS (thread local storage) のように事前には確保できない動的メモリに適している。 </dd></dl>

</div>
</div>
<a id="ga09e4f2ca3e8ee76141d1f6c931b0d862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09e4f2ca3e8ee76141d1f6c931b0d862">&#9670;&nbsp;</a></span>c7_mg_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* c7_mg_unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__c7memory.html#ga8dbd262c5860edef7b17371440d3a622">c7_mgroup_t</a>&#160;</td>
          <td class="paramname"><em>mg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>u_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>content_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mg のグループに所属する content_size バイトの u_addr メモリを mg のグループから切り離す。u_addr のアドレスは無意味になることに注意が必要。 </p>
<dl class="section return"><dt>Returns</dt><dd>u_addr メモリ移動後のデータのアドレスを戻す。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>切り離し処理により u_addr の指すメモリの内容がが数バイトオフセットされるため、u_addr に指定したポインタ値を使用してはならない。</li>
<li>メモリグループから切り離されるため、このメモリが不要になった場合は free で開放する必要がある。</li>
<li>mg が NULL ポインタの場合は u_addr がそのまま戻される。</li>
<li>u_addr が NULL の場合は NULL が戻される。</li>
<li>u_addr が mg とは異なるメモリグループであった場合も、、本来所属するメモリグループから切り離される。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae711ea17a571c63162ab8cef9affaeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae711ea17a571c63162ab8cef9affaeda">&#9670;&nbsp;</a></span>c7_sg_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c7types.html#ga32dffe853a91b70665fd4c3b18a9d288">c7_bool_t</a> c7_sg_push </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>現在のメモリグループをスタックへプッシュし、新しく作成したメモリグループを現在のメモリグループとする。 メモリを確保できれば <a class="el" href="group__c7types.html#gga32dffe853a91b70665fd4c3b18a9d288a08c6b322450e442caf038e6d5009ce3c" title="真 (C言語規格上では不正確)">C7_TRUE</a> を戻し、失敗すれば <a class="el" href="group__c7types.html#gga32dffe853a91b70665fd4c3b18a9d288a6a78d27e2a39c3f5ff8b63b6484e7359" title="偽 (C言語規格上で正確)">C7_FALSE</a> を戻す。 </p>
<p>この関数は後述の <a class="el" href="group__c7memory.html#gae711ea17a571c63162ab8cef9affaeda" title="現在のメモリグループをスタックへプッシュし、新しく作成したメモリグループを現在のメモリグループとする。 メモリを確保できれば C7_TRUE を戻し、失敗すれば C7_FALSE を戻す。">c7_sg_push()</a> と組み合わせて、関数における一時的な作業メモリの一括解放に利用できる。 例えば、イベントハンドラなどの入口と出口でそれぞれ <a class="el" href="group__c7memory.html#gae711ea17a571c63162ab8cef9affaeda" title="現在のメモリグループをスタックへプッシュし、新しく作成したメモリグループを現在のメモリグループとする。 メモリを確保できれば C7_TRUE を戻し、失敗すれば C7_FALSE を戻す。">c7_sg_push()</a>, <a class="el" href="group__c7memory.html#gab12ae39f16b183b9f35e870bc4e5040b" title="現在のメモリグループを完全に解放(c7_mg_destroy(c7_sg_current_mg()))し、 スタックからポップしたメモリグループを現在のメモリグループとする。 スタックからポップできれば...">c7_sg_pop()</a> を呼び出せば、ハンドラ 中に確保した作業メモリを容易に解放できる(簡易的なガーベージコレクション)。特に c7string による <b>C7文字列</b>ではバッファのメモリ確保・伸長が発生するためスタッカブルメモリグループは有用である。 </p>

</div>
</div>
<a id="ga5b37c8a5ffddbac98ff42e266ba024f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b37c8a5ffddbac98ff42e266ba024f9">&#9670;&nbsp;</a></span>c7_vbuf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* c7_vbuf_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__c7memory.html#ga79eed08ce542a1af97cd4be384663dba">c7_vbuf_t</a>&#160;</td>
          <td class="paramname"><em>vb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vbの可変バッファのサイズを最低 n バイト確保して、そのアドレスを戻す。 </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>確保済みのバッファサイズが n 以上であれば何もせずバッファのアドレスを戻す。realloc()のように バッファサイズを縮小する方向には機能しない。確保済みバッファが小さければ realloc 系関数で メモリの伸長が行われる。</li>
<li>vb が <a class="el" href="group__c7memory.html#ga84df286a4729be5f681650b3f9fde2e6" title="可変バッファの生成。メモリ確保・伸長は現在のスタック可能メモリグループで行なう。">c7_vbuf_new_sg()</a> で作成された場合、この関数の呼び出しでは、vb が生成された時点での メモリグループで <a class="el" href="group__c7memory.html#ga74a882028d678b0277f35fa78126eb90" title="realloc のメモリグループ版。mg が NULL ポインタの場合は c7_realloc() を呼びグループ化しない。  u_addr が mg とは異なるメモリグループであった場合、本来所属する...">c7_mg_realloc()</a> が呼ばれる。したがって、この関数の前に <a class="el" href="group__c7memory.html#gae711ea17a571c63162ab8cef9affaeda" title="現在のメモリグループをスタックへプッシュし、新しく作成したメモリグループを現在のメモリグループとする。 メモリを確保できれば C7_TRUE を戻し、失敗すれば C7_FALSE を戻す。">c7_sg_push()</a> して あった場合、バッファが伸長されたとしても、現在のスタック可能なメモリグループには属さない。 逆に <a class="el" href="group__c7memory.html#gab12ae39f16b183b9f35e870bc4e5040b" title="現在のメモリグループを完全に解放(c7_mg_destroy(c7_sg_current_mg()))し、 スタックからポップしたメモリグループを現在のメモリグループとする。 スタックからポップできれば...">c7_sg_pop()</a> されていた場合は、既に存在しないメモリグループへアクセスすることになるので、 この関数もしくは呼び出し側で破滅的な動作を引き起こすだろう。 </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
